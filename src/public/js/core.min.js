/*! 
 * onDomReady.js 1.4.0 (c) 2013 Tubal Martin - MIT license
 */
; (function (definition) {
    if (typeof define === "function" && define.amd) {
        // Register as an AMD module.
        define(definition);
    } else {
        // Browser globals
        window['onDomReady'] = definition();
    }
}(function () {

    'use strict';

    var win = window,
        doc = win.document,
        docElem = doc.documentElement,

        LOAD = "load",
        FALSE = false,
        ONLOAD = "on" + LOAD,
        COMPLETE = "complete",
        READYSTATE = "readyState",
        ATTACHEVENT = "attachEvent",
        DETACHEVENT = "detachEvent",
        ADDEVENTLISTENER = "addEventListener",
        DOMCONTENTLOADED = "DOMContentLoaded",
        ONREADYSTATECHANGE = "onreadystatechange",
        REMOVEEVENTLISTENER = "removeEventListener",

        // W3C Event model
        w3c = ADDEVENTLISTENER in doc,
        top = FALSE,

        // isReady: Is the DOM ready to be used? Set to true once it occurs.
        isReady = FALSE,

        // Callbacks pending execution until DOM is ready
        callbacks = [];

    // Handle when the DOM is ready
    function ready(fn) {
        if (!isReady) {

            // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
            if (!doc.body) {
                return defer(ready);
            }

            // Remember that the DOM is ready
            isReady = true;

            // Execute all callbacks
            while (fn = callbacks.shift()) {
                defer(fn);
            }
        }
    }

    // The ready event handler
    function completed(event) {
        // readyState === "complete" is good enough for us to call the dom ready in oldIE
        if (w3c || event.type === LOAD || doc[READYSTATE] === COMPLETE) {
            detach();
            ready();
        }
    }

    // Clean-up method for dom ready events
    function detach() {
        if (w3c) {
            doc[REMOVEEVENTLISTENER](DOMCONTENTLOADED, completed, FALSE);
            win[REMOVEEVENTLISTENER](LOAD, completed, FALSE);
        } else {
            doc[DETACHEVENT](ONREADYSTATECHANGE, completed);
            win[DETACHEVENT](ONLOAD, completed);
        }
    }

    // Defers a function, scheduling it to run after the current call stack has cleared.
    function defer(fn, wait) {
        // Allow 0 to be passed
        setTimeout(fn, +wait >= 0 ? wait : 1);
    }

    // Attach the listeners:

    // Catch cases where onDomReady is called after the browser event has already occurred.
    // we once tried to use readyState "interactive" here, but it caused issues like the one
    // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
    if (doc[READYSTATE] === COMPLETE) {
        // Handle it asynchronously to allow scripts the opportunity to delay ready
        defer(ready);

        // Standards-based browsers support DOMContentLoaded    
    } else if (w3c) {
        // Use the handy event callback
        doc[ADDEVENTLISTENER](DOMCONTENTLOADED, completed, FALSE);

        // A fallback to window.onload, that will always work
        win[ADDEVENTLISTENER](LOAD, completed, FALSE);

        // If IE event model is used
    } else {
        // Ensure firing before onload, maybe late but safe also for iframes
        doc[ATTACHEVENT](ONREADYSTATECHANGE, completed);

        // A fallback to window.onload, that will always work
        win[ATTACHEVENT](ONLOAD, completed);

        // If IE and not a frame
        // continually check to see if the document is ready
        try {
            top = win.frameElement == null && docElem;
        } catch (e) { }

        if (top && top.doScroll) {
            (function doScrollCheck() {
                if (!isReady) {
                    try {
                        // Use the trick by Diego Perini
                        // http://javascript.nwbox.com/IEContentLoaded/
                        top.doScroll("left");
                    } catch (e) {
                        return defer(doScrollCheck, 50);
                    }

                    // detach all dom ready events
                    detach();

                    // and execute any waiting functions
                    ready();
                }
            })();
        }
    }

    function onDomReady(fn) {
        // If DOM is ready, execute the function (async), otherwise wait
        isReady ? defer(fn) : callbacks.push(fn);
    }

    // Add version
    onDomReady.version = "1.4.0";
    // Add method to check if DOM is ready
    onDomReady.isReady = function () {
        return isReady;
    };

    return onDomReady;
}));
/*
 * majaX
 *
 * Copyright 2013, Simon Waldherr - http://simon.waldherr.eu/
 * Released under the MIT Licence
 * http://simon.waldherr.eu/license/mit/
 *
 * Github:  https://github.com/simonwaldherr/majaX.js/
 * Version: 0.2.6
 */

/*jslint browser: true, white: true, indent: 2, bitwise: true, regexp: true */
/*global ActiveXObject, window */
/*exported majaX */

var majaX, majax;

majaX = function (data, successcallback, errorcallback) {
    "use strict";
    var url, method, port, type, typed, header, faildata, ajax, ajaxTimeout, mimes, mimetype, senddata, sendkeys, sendstring, regex,
        urlparts = {},
        i = 0;
    if (data.url === undefined) {
        return false;
    }

    regex = /((http[s]?:\/\/)?([\.:\/?&]+)?([^\.:\/?&]+)?)/gm;
    urlparts.regex = data.url.match(regex);
    urlparts.clean = {
        'protocol': '',
        'domain': '',
        'port': '',
        'path': '',
        'fileextension': '',
        'query': ''
    };

    for (i = 0; i < urlparts.regex.length; i += 1) {
        if (majax.countChars(urlparts.regex[i], '://') === 1) {
            urlparts.clean.protocol = urlparts.regex[i] === undefined ? false : urlparts.regex[i].split('://')[0];
            urlparts.clean.domain = urlparts.regex[i] === undefined ? false : urlparts.regex[i].split('://')[1];
        } else if ((majax.countChars(urlparts.regex[i], '/') === 0) && (majax.countChars(urlparts.regex[i], ':') === 0) && (urlparts.clean.path === '')) {
            urlparts.clean.domain += urlparts.regex[i] === undefined ? false : urlparts.regex[i];
        } else if ((majax.countChars(urlparts.regex[i], ':') === 1) && (urlparts.clean.path === '')) {
            urlparts.clean.port = urlparts.regex[i] === undefined ? false : urlparts.regex[i].split(':')[1];
        } else if ((majax.countChars(urlparts.regex[i], '?') === 0) && (majax.countChars(urlparts.regex[i], '&') === 0) && (urlparts.clean.query === '')) {
            urlparts.clean.path += urlparts.regex[i] === undefined ? false : urlparts.regex[i];
        } else {
            urlparts.clean.query += urlparts.regex[i] === undefined ? false : urlparts.regex[i];
        }
    }
    if (urlparts.clean.path.indexOf(".") !== -1) {
        urlparts.clean.fileextension = urlparts.clean.path.split('.')[urlparts.clean.path.split('.').length - 1];
    }
    mimes = {
        'txt': 'text/plain',
        'json': 'application/json',
        'atom': 'application/atom+xml',
        'rss': 'application/rss+xml',
        'soap': 'application/soap+xml',
        'xml': 'application/xml',
        'svg': 'image/svg+xml',
        'css': 'text/css',
        'csv': 'text/csv',
        'html': 'text/html',
        'vcf': 'text/vcard',
        'gif': 'image/gif',
        'jpeg': 'image/jpeg',
        'jpg': 'image/jpeg',
        'png': 'image/png',
        'tiff': 'image/tiff',
        'mp3': 'audio/mpeg',
        'mp4': 'video/mpeg',
        'mpeg': 'video/mpeg',
        'mpg': 'video/mpeg',
        'm4a': 'audio/mp4',
        'ogg': 'audio/ogg',
        'oga': 'audio/ogg',
        'webma': 'audio/webm',
        'wav': 'audio/wav'
    };

    url = data.url === undefined ? false : data.url;
    method = data.method === undefined ? 'GET' : data.method.toUpperCase();
    port = data.port === undefined ? urlparts.clean.port === undefined ? '80' : urlparts.clean.port : data.port;
    typed = data.type === undefined ? urlparts.clean.fileextension === undefined ? 1 : 2 : 3;
    typed = data.mimetype === undefined ? typed : 4;
    type = data.type === undefined ? urlparts.clean.fileextension === undefined ? 'txt' : urlparts.clean.fileextension.toLowerCase() : data.type.toLowerCase();
    mimetype = data.mimetype === undefined ? mimes[urlparts.clean.fileextension] === undefined ? mimes[type] === undefined ? 'text/plain' : mimes[type] : mimes[urlparts.clean.fileextension] : data.mimetype;
    senddata = data.data === undefined ? false : data.data;
    faildata = data.faildata === undefined ? false : data.faildata;
    header = data.header === undefined ? {} : data.header;
    successcallback = data.success !== undefined ? data.success : successcallback;
    errorcallback = data.error !== undefined ? data.error : errorcallback;

    if (header['Content-type'] === undefined) {
        header['Content-type'] = 'application/x-www-form-urlencoded';
    }
    if (method === 'DEBUG') {
        return {
            "url": url,
            "urlparts": urlparts.clean,
            "port": port,
            "type": type,
            "mime": mimetype,
            "data": data
        };
    }
    ajax = (window.ActiveXObject) ? new ActiveXObject("Microsoft.XMLHTTP") : (XMLHttpRequest && new XMLHttpRequest()) || null;
    ajaxTimeout = window.setTimeout(function () {
        ajax.abort();
    }, 6000);
    ajax.onreadystatechange = function () {
        var jsoncontent, status;
        if (ajax.readyState === 4) {
            status = ajax.status.toString().charAt(0);
            clearTimeout(ajaxTimeout);
            ajax.headersObject = majax.getRespHeaders(ajax.getAllResponseHeaders());
            if ((status !== '2') && (status !== '3')) {
                errorcallback(faildata, ajax);
            } else {
                if (method === 'API') {
                    if (urlparts.clean.domain === 'github.com') {
                        jsoncontent = JSON.parse(ajax.responseText);
                        if (jsoncontent.content !== undefined) {
                            jsoncontent.content = majax.base64_decode(jsoncontent.content.replace(/\n/gmi, ''));
                            successcallback(jsoncontent, ajax);
                        } else {
                            successcallback(JSON.parse(ajax.responseText), ajax);
                        }
                    }
                } else if (method === 'HEAD') {
                    successcallback(ajax.responseText, ajax);
                } else {
                    if (typed < 3) {
                        mimetype = ajax.headersObject['Content-Type'];
                    }
                    if (mimetype.indexOf('json') !== -1) {
                        successcallback(JSON.parse(ajax.responseText), ajax);
                    } else if (mimetype.indexOf('xml') !== -1) {
                        successcallback(majax.getXMLasObject(ajax.responseText), ajax);
                    } else if (mimetype.indexOf('csv') !== -1) {
                        successcallback(majax.getCSVasArray(ajax.responseText), ajax);
                    } else if ((mimetype.indexOf('image') !== -1) || (mimetype.indexOf('video') !== -1) || (mimetype.indexOf('audio') !== -1) || (mimetype.indexOf('user-defined') !== -1)) {
                        successcallback(ajax.response, ajax);
                    } else {
                        successcallback(ajax.responseText, ajax);
                    }
                }
            }
        }
    };
    i = 0;
    sendstring = '';
    if (senddata !== false) {
        if ('string' === typeof senddata) {
            sendstring = senddata
        } else {
            for (sendkeys in senddata) {
                if (typeof senddata[sendkeys] === 'string') {
                    if (i !== 0) {
                        sendstring += '&';
                    }
                    sendstring += sendkeys + '=' + senddata[sendkeys];
                    i += 1;
                }
            }
        }
    }
    if (method === 'API') {
        if (urlparts.clean.domain === 'github.com') {
            mimetype = 'json';
            if (urlparts.clean.path.split('/')[2] === undefined) {
                ajax.open('GET', 'https://api.github.com/users/' + urlparts.clean.path.split('/')[1] + '/repos', true);
                majax.setReqHeaders(ajax, header);
                ajax.send();
            } else if (urlparts.clean.path.split('/')[3] === undefined) {
                ajax.open('GET', 'https://api.github.com/repos/' + urlparts.clean.path.split('/')[1] + '/' + urlparts.clean.path.split('/')[2] + '/contents/', true);
                majax.setReqHeaders(ajax, header);
                ajax.send();
            } else {
                ajax.open('GET', 'https://api.github.com/repos/' + urlparts.clean.path.split('/')[1] + '/' + urlparts.clean.path.split('/')[2] + '/contents/' + urlparts.clean.path.split('/', 4)[3], true);
                majax.setReqHeaders(ajax, header);
                ajax.send();
            }
        }
    } else {
        if (method !== 'POST') {
            if (sendstring !== '') {
                if (urlparts.clean.query !== '') {
                    url = url + '&' + sendstring;
                } else {
                    url = url + '?' + sendstring;
                }
            }
        }

        if (method === 'GET') {
            ajax.open('GET', url, true);
            majax.overrideMime(ajax, mimetype);
            majax.setReqHeaders(ajax, header);
            ajax.send();
        } else if (method === 'POST') {
            ajax.open('POST', url, true);
            majax.overrideMime(ajax, mimetype);
            majax.setReqHeaders(ajax, header);
            ajax.send(sendstring);
        } else {
            if (method === 'HEAD') {
                mimetype = 'none';
            }
            ajax.open(method, url, true);
            majax.overrideMime(ajax, mimetype);
            majax.setReqHeaders(ajax, header);
            ajax.send();
        }
    }
};

if ('undefined' !== typeof module) {
    module.exports = majaX
}

majax = {
    setReqHeaders: function (ajax, headerObject) {
        "use strict";
        var key;
        if (headerObject !== false) {
            if (typeof headerObject === 'object') {
                for (key in headerObject) {
                    if (typeof headerObject[key] === 'string') {
                        ajax.setRequestHeader(key, headerObject[key]);
                    }
                }
            }
        }
    },
    getRespHeaders: function (headerString) {
        "use strict";
        var i, string, header, headerObject = {};
        if (typeof headerString === 'string') {
            string = headerString.split(/\n/);
            for (i = 0; i < string.length; i += 1) {
                if (typeof string[i] === 'string') {
                    header = string[i].split(': ');
                    if ((header[0].length > 3) && (header[1].length > 3)) {
                        headerObject[header[0].trim()] = header[1].trim();
                    }
                }
            }
        }
        return headerObject;
    },
    overrideMime: function (ajax, mimetype) {
        "use strict";
        if (mimetype === 'application/xml') {
            ajax.overrideMimeType(mimetype);
            ajax.responseType = '';
        } else if ((mimetype.indexOf('image') !== -1) || (mimetype.indexOf('video') !== -1) || (mimetype.indexOf('audio') !== -1)) {
            ajax.overrideMimeType("text/plain; charset=x-user-defined");
            ajax.responseType = 'arraybuffer';
        }
    },
    countChars: function (string, split) {
        "use strict";
        string = string.split(split);
        if (typeof string === 'object') {
            return string.length - 1;
        }
        return 0;
    },
    getText: function (string) {
        "use strict";
        var re = /<([^<>]*)>([^\/]*)<(\/[^<>]*)>/gmi;
        if (typeof string === 'string') {
            return string.replace(re, '');
        }
    },
    getXMLasObject: function (xmlstring) {
        "use strict";
        var xmlroot, foo = {};
        if (typeof xmlstring === 'object') {
            return majax.returnChilds(foo, xmlstring, 1);
        }
        xmlroot = document.createElement('div');
        xmlroot.innerHTML = xmlstring;
        return majax.returnChilds(foo, xmlroot, 1);
    },
    returnChilds: function (element, node, deep) {
        "use strict";
        var i, ii, obj, key, plaintext, returnArray = [],
            childs = node.childNodes.length;
        ii = 0;
        for (i = 0; i < childs; i += 1) {
            if (node.childNodes[i].localName !== null) {
                element[ii] = {};
                for (key in node.childNodes[i]) {
                    if (node.childNodes[i][key] !== undefined) {
                        if ((typeof node.childNodes[i][key] === 'string') || (typeof node.childNodes[i][key] === 'number')) {
                            obj = node.childNodes[i][key];
                            if ((key !== 'accessKey') && (key !== 'baseURI') && (key !== 'className') && (key !== 'contentEditable') && (key !== 'dir') && (key !== 'namespaceURI') && (obj !== "") && (key !== key.toUpperCase()) && (obj !== 0) && (key !== 'childs') && (key !== 'textContent') && (key !== 'nodeType') && (key !== 'tabIndex') && (key !== 'innerHTML') && (key !== 'outerHTML')) {
                                element[ii][key] = obj;
                            } else if ((key === 'innerHTML') || (key === 'outerHTML')) {
                                element[ii][key] = majax.escapeHtmlEntities(obj);
                            }
                        }
                    }
                }
                if (node.childNodes[i].innerHTML !== undefined) {
                    plaintext = majax.getText(node.childNodes[i].innerHTML).trim();
                    if (plaintext !== "") {
                        element[ii].textContent = plaintext;
                    }
                    if (node.childNodes[i].childNodes.length > 1) {
                        element[ii].childs = majax.returnChilds(returnArray, node.childNodes[i], deep + 1);
                    }
                    ii += 1;
                }
            }
        }
        return element;
    },
    isEmpty: function (obj) {
        "use strict";
        var emptyObj = {}, emptyArr = [];
        if ((obj === emptyObj) || (obj === emptyArr) || (obj === null) || (obj === undefined)) {
            return true;
        }
        return false;
    },
    cleanArray: function (actual) {
        "use strict";
        var newArray = [],
            clean,
            i = 0;
        for (i = 0; i < actual.length; i += 1) {
            if ((typeof actual[i] === 'string') || (typeof actual[i] === 'number')) {
                newArray.push(actual[i]);
            } else if (typeof actual[i] === 'object') {
                clean = majax.cleanArray(actual[i]);
                if (clean[0] !== '') {
                    newArray.push(majax.cleanArray(actual[i]));
                }
            }
        }
        return newArray;
    },
    cleanObject: function (actual) {
        "use strict";
        var newArray = {}, key;
        for (key in actual) {
            if (actual[key] !== undefined) {
                if ((typeof actual[key] !== 'object') && (typeof actual[key] !== 'function') && (typeof actual[key] !== '') && (!majax.isEmpty(actual[key]))) {
                    newArray[key] = actual[key];
                } else if (typeof actual[key] === 'object') {
                    if ((!majax.isEmpty(majax.cleanObject(actual[key]))) && (actual[key] !== null)) {
                        newArray[key] = majax.cleanObject(actual[key]);
                    }
                }
            }
        }
        return newArray;
    },
    getCSVasArray: function (csvstring) {
        "use strict";
        var regexCSV, arrayCSV, arrMatches, strMatchedDelimiter, strMatchedValue, strDelimiter = ';';
        regexCSV = new RegExp(("(\\" + strDelimiter + "|\\r?\\n|\\r|^)" + "(?:\"([^\"]*(?:\"\"[^\"]*)*)\"|" + "([^\"\\" + strDelimiter + "\\r\\n]*))"), "gi");
        arrayCSV = [
            []
        ];
        arrMatches = regexCSV.exec(csvstring);
        while (arrMatches) {
            strMatchedDelimiter = arrMatches[1];
            if (strMatchedDelimiter.length && (strMatchedDelimiter !== strDelimiter)) {
                arrayCSV.push([]);
            }
            if (arrMatches[2]) {
                strMatchedValue = arrMatches[2].replace(new RegExp("\"\"", "g"), "\"");
            } else {
                strMatchedValue = arrMatches[3];
            }
            arrayCSV[arrayCSV.length - 1].push(strMatchedValue);
            arrMatches = regexCSV.exec(csvstring);
        }
        return majax.cleanArray(arrayCSV);
    },
    base64_encode: function (s) {
        "use strict";
        if (typeof window.btoa !== 'function') {
            var m = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                r = "",
                i = 0,
                a, b, c, d, x, y, z;
            while (i < s.length) {
                i += 1;
                x = s.charCodeAt(i);
                i += 1;
                y = s.charCodeAt(i);
                i += 1;
                z = s.charCodeAt(i);
                a = x >> 2;
                b = ((x & 3) << 4) | (y >> 4);
                c = ((y & 15) << 2) | (z >> 6);
                d = z & 63;
                if (isNaN(y)) {
                    c = d = 64;
                } else if (isNaN(z)) {
                    d = 64;
                }
                r += m.charAt(a) + m.charAt(b) + m.charAt(c) + m.charAt(d);
            }
            return r;
        }
        return window.btoa(s);
    },
    base64_decode: function (s) {
        "use strict";
        if (typeof window.btoa !== 'function') {
            var m = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                r = "",
                i = 0,
                a, b, c, d, x, y, z;
            s = s.replace(/[^A-Za-z0-9\+\/\=]/g, "");
            while (i < s.length) {
                i += 1;
                a = m.indexOf(s.charAt(i));
                i += 1;
                b = m.indexOf(s.charAt(i));
                i += 1;
                c = m.indexOf(s.charAt(i));
                i += 1;
                d = m.indexOf(s.charAt(i));
                x = (a << 2) | (b >> 4);
                y = ((b & 15) << 4) | (c >> 2);
                z = ((c & 3) << 6) | d;
                r += String.fromCharCode(x) + (c !== 64 ? String.fromCharCode(y) : "") + (d !== 64 ? String.fromCharCode(z) : "");
            }
            return r;
        }
        return window.atob(s);
    },
    escapeHtmlEntities: function (text) {
        "use strict";
        return text.replace(/[\u00A0-\u2666<>\&]/g, function (c) {
            var entityTable = { 34: 'quot', 38: 'amp', 39: 'apos', 60: 'lt', 62: 'gt', 160: 'nbsp', 161: 'iexcl', 162: 'cent', 163: 'pound', 164: 'curren', 165: 'yen', 166: 'brvbar', 167: 'sect', 168: 'uml', 169: 'copy', 170: 'ordf', 171: 'laquo', 172: 'not', 173: 'shy', 174: 'reg', 175: 'macr', 176: 'deg', 177: 'plusmn', 178: 'sup2', 179: 'sup3', 180: 'acute', 181: 'micro', 182: 'para', 183: 'middot', 184: 'cedil', 185: 'sup1', 186: 'ordm', 187: 'raquo', 188: 'frac14', 189: 'frac12', 190: 'frac34', 191: 'iquest', 192: 'Agrave', 193: 'Aacute', 194: 'Acirc', 195: 'Atilde', 196: 'Auml', 197: 'Aring', 198: 'AElig', 199: 'Ccedil', 200: 'Egrave', 201: 'Eacute', 202: 'Ecirc', 203: 'Euml', 204: 'Igrave', 205: 'Iacute', 206: 'Icirc', 207: 'Iuml', 208: 'ETH', 209: 'Ntilde', 210: 'Ograve', 211: 'Oacute', 212: 'Ocirc', 213: 'Otilde', 214: 'Ouml', 215: 'times', 216: 'Oslash', 217: 'Ugrave', 218: 'Uacute', 219: 'Ucirc', 220: 'Uuml', 221: 'Yacute', 222: 'THORN', 223: 'szlig', 224: 'agrave', 225: 'aacute', 226: 'acirc', 227: 'atilde', 228: 'auml', 229: 'aring', 230: 'aelig', 231: 'ccedil', 232: 'egrave', 233: 'eacute', 234: 'ecirc', 235: 'euml', 236: 'igrave', 237: 'iacute', 238: 'icirc', 239: 'iuml', 240: 'eth', 241: 'ntilde', 242: 'ograve', 243: 'oacute', 244: 'ocirc', 245: 'otilde', 246: 'ouml', 247: 'divide', 248: 'oslash', 249: 'ugrave', 250: 'uacute', 251: 'ucirc', 252: 'uuml', 253: 'yacute', 254: 'thorn', 255: 'yuml', 402: 'fnof', 913: 'Alpha', 914: 'Beta', 915: 'Gamma', 916: 'Delta', 917: 'Epsilon', 918: 'Zeta', 919: 'Eta', 920: 'Theta', 921: 'Iota', 922: 'Kappa', 923: 'Lambda', 924: 'Mu', 925: 'Nu', 926: 'Xi', 927: 'Omicron', 928: 'Pi', 929: 'Rho', 931: 'Sigma', 932: 'Tau', 933: 'Upsilon', 934: 'Phi', 935: 'Chi', 936: 'Psi', 937: 'Omega', 945: 'alpha', 946: 'beta', 947: 'gamma', 948: 'delta', 949: 'epsilon', 950: 'zeta', 951: 'eta', 952: 'theta', 953: 'iota', 954: 'kappa', 955: 'lambda', 956: 'mu', 957: 'nu', 958: 'xi', 959: 'omicron', 960: 'pi', 961: 'rho', 962: 'sigmaf', 963: 'sigma', 964: 'tau', 965: 'upsilon', 966: 'phi', 967: 'chi', 968: 'psi', 969: 'omega', 977: 'thetasym', 978: 'upsih', 982: 'piv', 8226: 'bull', 8230: 'hellip', 8242: 'prime', 8243: 'Prime', 8254: 'oline', 8260: 'frasl', 8472: 'weierp', 8465: 'image', 8476: 'real', 8482: 'trade', 8501: 'alefsym', 8592: 'larr', 8593: 'uarr', 8594: 'rarr', 8595: 'darr', 8596: 'harr', 8629: 'crarr', 8656: 'lArr', 8657: 'uArr', 8658: 'rArr', 8659: 'dArr', 8660: 'hArr', 8704: 'forall', 8706: 'part', 8707: 'exist', 8709: 'empty', 8711: 'nabla', 8712: 'isin', 8713: 'notin', 8715: 'ni', 8719: 'prod', 8721: 'sum', 8722: 'minus', 8727: 'lowast', 8730: 'radic', 8733: 'prop', 8734: 'infin', 8736: 'ang', 8743: 'and', 8744: 'or', 8745: 'cap', 8746: 'cup', 8747: 'int', 8756: 'there4', 8764: 'sim', 8773: 'cong', 8776: 'asymp', 8800: 'ne', 8801: 'equiv', 8804: 'le', 8805: 'ge', 8834: 'sub', 8835: 'sup', 8836: 'nsub', 8838: 'sube', 8839: 'supe', 8853: 'oplus', 8855: 'otimes', 8869: 'perp', 8901: 'sdot', 8968: 'lceil', 8969: 'rceil', 8970: 'lfloor', 8971: 'rfloor', 9001: 'lang', 9002: 'rang', 9674: 'loz', 9824: 'spades', 9827: 'clubs', 9829: 'hearts', 9830: 'diams', 338: 'OElig', 339: 'oelig', 352: 'Scaron', 353: 'scaron', 376: 'Yuml', 710: 'circ', 732: 'tilde', 8194: 'ensp', 8195: 'emsp', 8201: 'thinsp', 8204: 'zwnj', 8205: 'zwj', 8206: 'lrm', 8207: 'rlm', 8211: 'ndash', 8212: 'mdash', 8216: 'lsquo', 8217: 'rsquo', 8218: 'sbquo', 8220: 'ldquo', 8221: 'rdquo', 8222: 'bdquo', 8224: 'dagger', 8225: 'Dagger', 8240: 'permil', 8249: 'lsaquo', 8250: 'rsaquo', 8364: 'euro' };
            return '&' + (entityTable[c.charCodeAt(0)] || '#' + c.charCodeAt(0)) + ';';
        });
    }
};
/*!
 * Bowser - a browser detector
 * https://github.com/ded/bowser
 * MIT License | (c) Dustin Diaz 2015
 */

!function (root, name, definition) {
    if (typeof module != 'undefined' && module.exports) module.exports = definition()
    else if (typeof define == 'function' && define.amd) define(name, definition)
    else root[name] = definition()
}(this, 'bowser', function () {
    /**
      * See useragents.js for examples of navigator.userAgent
      */

    var t = true

    function detect(ua) {

        function getFirstMatch(regex) {
            var match = ua.match(regex);
            return (match && match.length > 1 && match[1]) || '';
        }

        function getSecondMatch(regex) {
            var match = ua.match(regex);
            return (match && match.length > 1 && match[2]) || '';
        }

        var iosdevice = getFirstMatch(/(ipod|iphone|ipad)/i).toLowerCase()
            , likeAndroid = /like android/i.test(ua)
            , android = !likeAndroid && /android/i.test(ua)
            , nexusMobile = /nexus\s*[0-6]\s*/i.test(ua)
            , nexusTablet = !nexusMobile && /nexus\s*[0-9]+/i.test(ua)
            , chromeos = /CrOS/.test(ua)
            , silk = /silk/i.test(ua)
            , sailfish = /sailfish/i.test(ua)
            , tizen = /tizen/i.test(ua)
            , webos = /(web|hpw)os/i.test(ua)
            , windowsphone = /windows phone/i.test(ua)
            , samsungBrowser = /SamsungBrowser/i.test(ua)
            , windows = !windowsphone && /windows/i.test(ua)
            , mac = !iosdevice && !silk && /macintosh/i.test(ua)
            , linux = !android && !sailfish && !tizen && !webos && /linux/i.test(ua)
            , edgeVersion = getFirstMatch(/edge\/(\d+(\.\d+)?)/i)
            , versionIdentifier = getFirstMatch(/version\/(\d+(\.\d+)?)/i)
            , tablet = /tablet/i.test(ua) && !/tablet pc/i.test(ua)
            , mobile = !tablet && /[^-]mobi/i.test(ua)
            , xbox = /xbox/i.test(ua)
            , result

        if (/opera/i.test(ua)) {
            //  an old Opera
            result = {
                name: 'Opera'
                , opera: t
                , version: versionIdentifier || getFirstMatch(/(?:opera|opr|opios)[\s\/](\d+(\.\d+)?)/i)
            }
        } else if (/opr\/|opios/i.test(ua)) {
            // a new Opera
            result = {
                name: 'Opera'
                , opera: t
                , version: getFirstMatch(/(?:opr|opios)[\s\/](\d+(\.\d+)?)/i) || versionIdentifier
            }
        }
        else if (/SamsungBrowser/i.test(ua)) {
            result = {
                name: 'Samsung Internet for Android'
                , samsungBrowser: t
                , version: versionIdentifier || getFirstMatch(/(?:SamsungBrowser)[\s\/](\d+(\.\d+)?)/i)
            }
        }
        else if (/coast/i.test(ua)) {
            result = {
                name: 'Opera Coast'
                , coast: t
                , version: versionIdentifier || getFirstMatch(/(?:coast)[\s\/](\d+(\.\d+)?)/i)
            }
        }
        else if (/yabrowser/i.test(ua)) {
            result = {
                name: 'Yandex Browser'
                , yandexbrowser: t
                , version: versionIdentifier || getFirstMatch(/(?:yabrowser)[\s\/](\d+(\.\d+)?)/i)
            }
        }
        else if (/ucbrowser/i.test(ua)) {
            result = {
                name: 'UC Browser'
                , ucbrowser: t
                , version: getFirstMatch(/(?:ucbrowser)[\s\/](\d+(?:\.\d+)+)/i)
            }
        }
        else if (/mxios/i.test(ua)) {
            result = {
                name: 'Maxthon'
                , maxthon: t
                , version: getFirstMatch(/(?:mxios)[\s\/](\d+(?:\.\d+)+)/i)
            }
        }
        else if (/epiphany/i.test(ua)) {
            result = {
                name: 'Epiphany'
                , epiphany: t
                , version: getFirstMatch(/(?:epiphany)[\s\/](\d+(?:\.\d+)+)/i)
            }
        }
        else if (/puffin/i.test(ua)) {
            result = {
                name: 'Puffin'
                , puffin: t
                , version: getFirstMatch(/(?:puffin)[\s\/](\d+(?:\.\d+)?)/i)
            }
        }
        else if (/sleipnir/i.test(ua)) {
            result = {
                name: 'Sleipnir'
                , sleipnir: t
                , version: getFirstMatch(/(?:sleipnir)[\s\/](\d+(?:\.\d+)+)/i)
            }
        }
        else if (/k-meleon/i.test(ua)) {
            result = {
                name: 'K-Meleon'
                , kMeleon: t
                , version: getFirstMatch(/(?:k-meleon)[\s\/](\d+(?:\.\d+)+)/i)
            }
        }
        else if (windowsphone) {
            result = {
                name: 'Windows Phone'
                , windowsphone: t
            }
            if (edgeVersion) {
                result.msedge = t
                result.version = edgeVersion
            }
            else {
                result.msie = t
                result.version = getFirstMatch(/iemobile\/(\d+(\.\d+)?)/i)
            }
        }
        else if (/msie|trident/i.test(ua)) {
            result = {
                name: 'Internet Explorer'
                , msie: t
                , version: getFirstMatch(/(?:msie |rv:)(\d+(\.\d+)?)/i)
            }
        } else if (chromeos) {
            result = {
                name: 'Chrome'
                , chromeos: t
                , chromeBook: t
                , chrome: t
                , version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
            }
        } else if (/chrome.+? edge/i.test(ua)) {
            result = {
                name: 'Microsoft Edge'
                , msedge: t
                , version: edgeVersion
            }
        }
        else if (/vivaldi/i.test(ua)) {
            result = {
                name: 'Vivaldi'
                , vivaldi: t
                , version: getFirstMatch(/vivaldi\/(\d+(\.\d+)?)/i) || versionIdentifier
            }
        }
        else if (sailfish) {
            result = {
                name: 'Sailfish'
                , sailfish: t
                , version: getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i)
            }
        }
        else if (/seamonkey\//i.test(ua)) {
            result = {
                name: 'SeaMonkey'
                , seamonkey: t
                , version: getFirstMatch(/seamonkey\/(\d+(\.\d+)?)/i)
            }
        }
        else if (/firefox|iceweasel|fxios/i.test(ua)) {
            result = {
                name: 'Firefox'
                , firefox: t
                , version: getFirstMatch(/(?:firefox|iceweasel|fxios)[ \/](\d+(\.\d+)?)/i)
            }
            if (/\((mobile|tablet);[^\)]*rv:[\d\.]+\)/i.test(ua)) {
                result.firefoxos = t
            }
        }
        else if (silk) {
            result = {
                name: 'Amazon Silk'
                , silk: t
                , version: getFirstMatch(/silk\/(\d+(\.\d+)?)/i)
            }
        }
        else if (/phantom/i.test(ua)) {
            result = {
                name: 'PhantomJS'
                , phantom: t
                , version: getFirstMatch(/phantomjs\/(\d+(\.\d+)?)/i)
            }
        }
        else if (/slimerjs/i.test(ua)) {
            result = {
                name: 'SlimerJS'
                , slimer: t
                , version: getFirstMatch(/slimerjs\/(\d+(\.\d+)?)/i)
            }
        }
        else if (/blackberry|\bbb\d+/i.test(ua) || /rim\stablet/i.test(ua)) {
            result = {
                name: 'BlackBerry'
                , blackberry: t
                , version: versionIdentifier || getFirstMatch(/blackberry[\d]+\/(\d+(\.\d+)?)/i)
            }
        }
        else if (webos) {
            result = {
                name: 'WebOS'
                , webos: t
                , version: versionIdentifier || getFirstMatch(/w(?:eb)?osbrowser\/(\d+(\.\d+)?)/i)
            };
            /touchpad\//i.test(ua) && (result.touchpad = t)
        }
        else if (/bada/i.test(ua)) {
            result = {
                name: 'Bada'
                , bada: t
                , version: getFirstMatch(/dolfin\/(\d+(\.\d+)?)/i)
            };
        }
        else if (tizen) {
            result = {
                name: 'Tizen'
                , tizen: t
                , version: getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.\d+)?)/i) || versionIdentifier
            };
        }
        else if (/qupzilla/i.test(ua)) {
            result = {
                name: 'QupZilla'
                , qupzilla: t
                , version: getFirstMatch(/(?:qupzilla)[\s\/](\d+(?:\.\d+)+)/i) || versionIdentifier
            }
        }
        else if (/chromium/i.test(ua)) {
            result = {
                name: 'Chromium'
                , chromium: t
                , version: getFirstMatch(/(?:chromium)[\s\/](\d+(?:\.\d+)?)/i) || versionIdentifier
            }
        }
        else if (/chrome|crios|crmo/i.test(ua)) {
            result = {
                name: 'Chrome'
                , chrome: t
                , version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
            }
        }
        else if (android) {
            result = {
                name: 'Android'
                , version: versionIdentifier
            }
        }
        else if (/safari|applewebkit/i.test(ua)) {
            result = {
                name: 'Safari'
                , safari: t
            }
            if (versionIdentifier) {
                result.version = versionIdentifier
            }
        }
        else if (iosdevice) {
            result = {
                name: iosdevice == 'iphone' ? 'iPhone' : iosdevice == 'ipad' ? 'iPad' : 'iPod'
            }
            // WTF: version is not part of user agent in web apps
            if (versionIdentifier) {
                result.version = versionIdentifier
            }
        }
        else if (/googlebot/i.test(ua)) {
            result = {
                name: 'Googlebot'
                , googlebot: t
                , version: getFirstMatch(/googlebot\/(\d+(\.\d+))/i) || versionIdentifier
            }
        }
        else {
            result = {
                name: getFirstMatch(/^(.*)\/(.*) /),
                version: getSecondMatch(/^(.*)\/(.*) /)
            };
        }

        // set webkit or gecko flag for browsers based on these engines
        if (!result.msedge && /(apple)?webkit/i.test(ua)) {
            if (/(apple)?webkit\/537\.36/i.test(ua)) {
                result.name = result.name || "Blink"
                result.blink = t
            } else {
                result.name = result.name || "Webkit"
                result.webkit = t
            }
            if (!result.version && versionIdentifier) {
                result.version = versionIdentifier
            }
        } else if (!result.opera && /gecko\//i.test(ua)) {
            result.name = result.name || "Gecko"
            result.gecko = t
            result.version = result.version || getFirstMatch(/gecko\/(\d+(\.\d+)?)/i)
        }

        // set OS flags for platforms that have multiple browsers
        if (!result.windowsphone && !result.msedge && (android || result.silk)) {
            result.android = t
        } else if (!result.windowsphone && !result.msedge && iosdevice) {
            result[iosdevice] = t
            result.ios = t
        } else if (mac) {
            result.mac = t
        } else if (xbox) {
            result.xbox = t
        } else if (windows) {
            result.windows = t
        } else if (linux) {
            result.linux = t
        }

        function getWindowsVersion(s) {
            switch (s) {
                case 'NT': return 'NT'
                case 'XP': return 'XP'
                case 'NT 5.0': return '2000'
                case 'NT 5.1': return 'XP'
                case 'NT 5.2': return '2003'
                case 'NT 6.0': return 'Vista'
                case 'NT 6.1': return '7'
                case 'NT 6.2': return '8'
                case 'NT 6.3': return '8.1'
                case 'NT 10.0': return '10'
                default: return undefined
            }
        }

        // OS version extraction
        var osVersion = '';
        if (result.windows) {
            osVersion = getWindowsVersion(getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i))
        } else if (result.windowsphone) {
            osVersion = getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i);
        } else if (result.mac) {
            osVersion = getFirstMatch(/Mac OS X (\d+([_\.\s]\d+)*)/i);
            osVersion = osVersion.replace(/[_\s]/g, '.');
        } else if (iosdevice) {
            osVersion = getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i);
            osVersion = osVersion.replace(/[_\s]/g, '.');
        } else if (android) {
            osVersion = getFirstMatch(/android[ \/-](\d+(\.\d+)*)/i);
        } else if (result.webos) {
            osVersion = getFirstMatch(/(?:web|hpw)os\/(\d+(\.\d+)*)/i);
        } else if (result.blackberry) {
            osVersion = getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i);
        } else if (result.bada) {
            osVersion = getFirstMatch(/bada\/(\d+(\.\d+)*)/i);
        } else if (result.tizen) {
            osVersion = getFirstMatch(/tizen[\/\s](\d+(\.\d+)*)/i);
        }
        if (osVersion) {
            result.osversion = osVersion;
        }

        // device type extraction
        var osMajorVersion = !result.windows && osVersion.split('.')[0];
        if (
            tablet
            || nexusTablet
            || iosdevice == 'ipad'
            || (android && (osMajorVersion == 3 || (osMajorVersion >= 4 && !mobile)))
            || result.silk
        ) {
            result.tablet = t
        } else if (
            mobile
            || iosdevice == 'iphone'
            || iosdevice == 'ipod'
            || android
            || nexusMobile
            || result.blackberry
            || result.webos
            || result.bada
        ) {
            result.mobile = t
        }

        // Graded Browser Support
        // http://developer.yahoo.com/yui/articles/gbs
        if (result.msedge ||
            (result.msie && result.version >= 10) ||
            (result.yandexbrowser && result.version >= 15) ||
            (result.vivaldi && result.version >= 1.0) ||
            (result.chrome && result.version >= 20) ||
            (result.samsungBrowser && result.version >= 4) ||
            (result.firefox && result.version >= 20.0) ||
            (result.safari && result.version >= 6) ||
            (result.opera && result.version >= 10.0) ||
            (result.ios && result.osversion && result.osversion.split(".")[0] >= 6) ||
            (result.blackberry && result.version >= 10.1)
            || (result.chromium && result.version >= 20)
        ) {
            result.a = t;
        }
        else if ((result.msie && result.version < 10) ||
            (result.chrome && result.version < 20) ||
            (result.firefox && result.version < 20.0) ||
            (result.safari && result.version < 6) ||
            (result.opera && result.version < 10.0) ||
            (result.ios && result.osversion && result.osversion.split(".")[0] < 6)
            || (result.chromium && result.version < 20)
        ) {
            result.c = t
        } else result.x = t

        return result
    }

    var bowser = detect(typeof navigator !== 'undefined' ? navigator.userAgent || '' : '')

    bowser.test = function (browserList) {
        for (var i = 0; i < browserList.length; ++i) {
            var browserItem = browserList[i];
            if (typeof browserItem === 'string') {
                if (browserItem in bowser) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Get version precisions count
     *
     * @example
     *   getVersionPrecision("1.10.3") // 3
     *
     * @param  {string} version
     * @return {number}
     */
    function getVersionPrecision(version) {
        return version.split(".").length;
    }

    /**
     * Array::map polyfill
     *
     * @param  {Array} arr
     * @param  {Function} iterator
     * @return {Array}
     */
    function map(arr, iterator) {
        var result = [], i;
        if (Array.prototype.map) {
            return Array.prototype.map.call(arr, iterator);
        }
        for (i = 0; i < arr.length; i++) {
            result.push(iterator(arr[i]));
        }
        return result;
    }

    /**
     * Calculate browser version weight
     *
     * @example
     *   compareVersions(['1.10.2.1',  '1.8.2.1.90'])    // 1
     *   compareVersions(['1.010.2.1', '1.09.2.1.90']);  // 1
     *   compareVersions(['1.10.2.1',  '1.10.2.1']);     // 0
     *   compareVersions(['1.10.2.1',  '1.0800.2']);     // -1
     *
     * @param  {Array<String>} versions versions to compare
     * @return {Number} comparison result
     */
    function compareVersions(versions) {
        // 1) get common precision for both versions, for example for "10.0" and "9" it should be 2
        var precision = Math.max(getVersionPrecision(versions[0]), getVersionPrecision(versions[1]));
        var chunks = map(versions, function (version) {
            var delta = precision - getVersionPrecision(version);

            // 2) "9" -> "9.0" (for precision = 2)
            version = version + new Array(delta + 1).join(".0");

            // 3) "9.0" -> ["000000000"", "000000009"]
            return map(version.split("."), function (chunk) {
                return new Array(20 - chunk.length).join("0") + chunk;
            }).reverse();
        });

        // iterate in reverse order by reversed chunks array
        while (--precision >= 0) {
            // 4) compare: "000000009" > "000000010" = false (but "9" > "10" = true)
            if (chunks[0][precision] > chunks[1][precision]) {
                return 1;
            }
            else if (chunks[0][precision] === chunks[1][precision]) {
                if (precision === 0) {
                    // all version chunks are same
                    return 0;
                }
            }
            else {
                return -1;
            }
        }
    }

    /**
     * Check if browser is unsupported
     *
     * @example
     *   bowser.isUnsupportedBrowser({
     *     msie: "10",
     *     firefox: "23",
     *     chrome: "29",
     *     safari: "5.1",
     *     opera: "16",
     *     phantom: "534"
     *   });
     *
     * @param  {Object}  minVersions map of minimal version to browser
     * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map
     * @param  {String}  [ua] user agent string
     * @return {Boolean}
     */
    function isUnsupportedBrowser(minVersions, strictMode, ua) {
        var _bowser = bowser;

        // make strictMode param optional with ua param usage
        if (typeof strictMode === 'string') {
            ua = strictMode;
            strictMode = void (0);
        }

        if (strictMode === void (0)) {
            strictMode = false;
        }
        if (ua) {
            _bowser = detect(ua);
        }

        var version = "" + _bowser.version;
        for (var browser in minVersions) {
            if (minVersions.hasOwnProperty(browser)) {
                if (_bowser[browser]) {
                    if (typeof minVersions[browser] !== 'string') {
                        throw new Error('Browser version in the minVersion map should be a string: ' + browser + ': ' + String(minVersions));
                    }

                    // browser version and min supported version.
                    return compareVersions([version, minVersions[browser]]) < 0;
                }
            }
        }

        return strictMode; // not found
    }

    /**
     * Check if browser is supported
     *
     * @param  {Object} minVersions map of minimal version to browser
     * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map
     * @param  {String}  [ua] user agent string
     * @return {Boolean}
     */
    function check(minVersions, strictMode, ua) {
        return !isUnsupportedBrowser(minVersions, strictMode, ua);
    }

    bowser.isUnsupportedBrowser = isUnsupportedBrowser;
    bowser.compareVersions = compareVersions;
    bowser.check = check;

    /*
     * Set our detect method to the main bowser object so we can
     * reuse it to test other user agents.
     * This is needed to implement future tests.
     */
    bowser._detect = detect;

    return bowser
});
function has(obj, key) {
    return hasOwnProperty.call(obj, key);
}

function isEmpty(obj) {
    if (obj === null) {
        return true;
    }
    if (isArray(obj) || isString(obj)) {
        return obj.length === 0;
    }
    var key = 0;
    for (key in obj) {
        if (has(obj, key)) {
            return false;
        }
    }
    return true;
}

function trim(text) {
    return (text || '').replace(/^\s+|\s+$/g, '');
}

function parseJSON(obj) {
    return (window.JSON && JSON.parse) ? JSON.parse(obj) : eval('(' + obj + ')');
}

function isFunction(obj) {
    return toString.call(obj) === '[object Function]';
}

function rand(mi, ma) {
    return Math.random() * (ma - mi + 1) + mi;
}

function irand(mi, ma) {
    return Math.floor(rand(mi, ma));
}

function isElement(obj) {
    return !!(obj && obj.nodeType === 1);
}

function isArray(obj) {
    return toString.call(obj) === '[object Array]';
}

function isNodeList(obj) {
    return toString.call(obj) === '[object NodeList]';
}

function isObject(obj) {
    return Object.prototype.toString.call(obj) === '[object Object]';
}

function isMouseEvent(obj) {
    return toString.call(obj) === '[object MouseEvent]';
}

function isArguments(obj) {
    return toString.call(obj) === '[object Arguments]';
}

function isHtmlDiv(obj) {
    return toString.call(obj) === '[object HTMLDivElement]';
}

function isString(obj) {
    return toString.call(obj) === '[object String]';
}

function isNumber(obj) {
    return toString.call(obj) === '[object Number]';
}

function isBoolean(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
}

function isDate(obj) {
    return toString.call(obj) === '[object Date]';
}

function isRegExp(obj) {
    return toString.call(obj) === '[object RegExp]';
}

function isNull(obj) {
    return obj === null;
}

function isUndefined(obj) {
    return obj === void 0;
}

function stringify(object) {
    return JSON.stringify(object);
}

function emptyFunction() { }

function unfilterJSON(str, filter) {
    return str.replace(filter || /^\/\*-secure-([\s\S]*)\*\/\s*$/, '$1');
}

function escapeHTML(str) {
    return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function unescapeHTML(str) {
    return str.stripTags().replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&');
}

function strip(str) {
    return str.replace(/^\s+/, '').replace(/\s+$/, '');
}

function stripTags(str) {
    return str.replace(/<\w+(\s+("[^"]*"|'[^']*'|[^>])+)?>|<\/\w+>/gi, '');
}

function stripScripts(str) {
    return str.replace(new RegExp('<script[^>]*>([\\S\\s]*?)<\/script>', 'img'), '');
}

function evalScripts(str) {
    var scripts;
    while (scripts = /<script[^>]*>([\s\S]+?)<\/script>/gi.exec(str)) {
        eval.call(window, scripts[1]);
    }
    return str;
}

function match(element, selector) {
    if (isString(selector)) {
        return Prototype.Selector.match(element, selector);
    }
    return selector.match(element);
}

function now() {
    return (new Date()).getTime();
}

function extend() {
    var a = arguments, target = a[0] || {}, i = 1, l = a.length, deep = false, options;

    if (typeof target === 'boolean') {
        deep = target;
        target = a[1] || {};
        i = 2;
    }

    if (typeof target !== 'object' && !isFunction(target))
        target = {};

    for (; i < l; ++i) {
        if ((options = a[i]) != null) {
            for (var name in options) {
                var src = target[name], copy = options[name];

                if (target === copy)
                    continue;

                if (deep && copy && typeof copy === 'object' && !copy.nodeType) {
                    target[name] = extend(deep, src || (copy.length != null ? [] : {}), copy);
                } else if (copy !== undefined) {
                    target[name] = copy;
                }
            }
        }
    }

    return target;
}

function each(obj, iterator, context) {
    var nativeForEach = Array.prototype.forEach,
        i = 0,
        l = 0,
        key = {};
    if (obj === null) {
        return false;
    }
    if (nativeForEach && obj.forEach === nativeForEach) {
        obj.forEach(iterator, context);
    } else {
        if (obj.length === +obj.length) {
            for (i = 0, l = obj.length; i < l; i += 1) {
                if (has(obj, i) && isObject(iterator.call(context, obj[i], i, obj))) {
                    return false;
                }
            }
        } else {
            for (key in obj) {
                if (has(obj, key)) {
                    if (isObject(iterator.call(context, obj[key], key, obj))) {
                        return false;
                    }
                }
            }
        }
    }
}

function indexOf(arr, value, from) {
    var i = 0,
        l = arr.length;
    for (i = (from || 0); i < l; i += 1) {
        if (arr[i] === value) {
            return i;
        }
    }
    return -1;
}

function choice() {
    var returnValue = null,
        i = 0,
        lambda = 0;

    for (i = 0; i < arguments.length; i += 1) {
        lambda = arguments[i];
        try {
            returnValue = lambda();
            break;
        } catch (e) {
            console.log('Error: ' + e);
        }
    }

    return returnValue;
}

function getHostname() {
    return location.protocol + '//' + location.host;
}

function url2obj(hash) {
    var action,
        obj = {},
        properties = '',
        p = '';
    action = hash.substr(0, 3) === '#!/' ? hash.substr(2) : hash;
    obj.hash = action;
    if (indexOf(action, '?') > 0) {
        properties = action.split('?');
        obj.hash = properties[0];
        properties = properties[1].split(/&/);
        obj.params = {};
        each(properties, function (k) {
            p = k.split('=');
            obj.params[p[0]] = p[1];
        });
    }
    return obj;
}

function history(callback) {
    window.addEvent("hashchange", callback);
    return true;
}

function top() {
    return document.documentElement.scrollTop || document.body.scrollTop;
}

function getWidth() {
    return window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
}

function getHeight() {
    return window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
}

function total(d) {
    var b = document.body,
        e = document.documentElement;
    return d ? Math.max(Math.max(b.scrollHeight, e.scrollHeight), Math.max(b.clientHeight, e.clientHeight)) : Math.max(Math.max(b.scrollWidth, e.scrollWidth), Math.max(b.clientWidth, e.clientWidth));
}

Object.prototype.addEvent = function (sEvent, fnHandler, bUseCapture) {
    if (this.attachEvent) {
        this.attachEvent('on' + sEvent, fnHandler, bUseCapture);
    } else {
        this.addEventListener(sEvent, fnHandler, bUseCapture);
    }
    return this;
};

Object.prototype.removeEvent = function (sEvent, fnHandler, bUseCapture) {
    if (this.detachEvent) {
        this.detachEvent('on' + sEvent, fnHandler, bUseCapture);
    } else {
        this.removeEventListener(sEvent, fnHandler, bUseCapture);
    }
    return this;
};

Function.prototype.bind = function (object) {
    var __method = this;
    return function () {
        return __method.apply(object, arguments);
    };
};

String.prototype.hashCode = function () {
    var hash = 0,
        c = '';
    if (this.length === 0) {
        return hash;
    }
    for (var i = 0; i < this.length; i += 1) {
        c = this.charCodeAt(i);
        hash = ((hash << 5) - hash) + c;
        hash = hash & hash;
        // Convert to 32bit integer
    }
    return hash;
};
function createElement(tagName, attr, style) {

    var el = document.createElement(tagName);
    if (attr) {
        extend(el, attr);
    }
    if (style) {
        css(el).set(style);
    }
    return el;
}

function createFragment(doc) {
    doc = doc || document;
    var frag = doc.createDocumentFragment(),
        elem = doc.createElement('div'),
        range = doc.createRange;

    frag.appendChild(elem);
    if (range) {
        range.selectNodeContents(elem);
        return range.createContextualFragment ? function (html) {
            if (!html) {
                return doc.createDocumentFragment();
            }
            return range.createContextualFragment(html);
        } : function (html) {
            if (!html) {
                return doc.createDocumentFragment();
            }
            elem.innerHTML = html;
            while (elem.firstChild) {
                frag.appendChild(elem.firstChild);
            }
            return frag;
        };
    }
}

function show(elem) {
    if (!elem || !elem.style) {
        return false;
    }
    var i = 0,
        l = 0,
        old = elem.olddisplay,
        newStyle = 'block',
        tag = elem.tagName.toLowerCase();

    if (arguments.length > 1) {
        for (l = arguments.length; i < l; i += 1) {
            show(arguments[i]);
        }
        return true;
    }
    css(elem).set('display', old || '');

    if (css(elem).get('display') === 'none') {
        if (css(elem).hasClass('inline')) {
            newStyle = 'inline';
        }
        else {
            if (tag === 'tr' && !browser.msie) {
                newStyle = 'table-row';
            }
            else {
                if (tag === 'table' && !browser.msie) {
                    newStyle = 'table';
                }
                else {
                    newStyle = 'block';
                }
            }
        }
        elem.olddisplay = newStyle;
        css(elem).set('display', newStyle);
    }
}

function hide(elem) {
    if (!elem || !elem.style) {
        return false;
    }
    var l = arguments.length,
        i = 0,
        d = 0;
    if (l > 1) {
        for (i = 0; i < l; i += 1) {
            hide(arguments[i]);
        }
        return true;
    }
    d = css(elem).get('display');
    elem.olddisplay = (d !== 'none') ? d : '';
    css(elem).set('display', 'none');
}

function isVisible(elem) {
    if (!elem || !elem.style) {
        return false;
    }
    return css(elem).get('display') !== 'none';
}

function toggle(elem, v) {
    if (v === undefined) {
        v = !isVisible(elem);
    }
    if (v) {
        show(elem);
    }
    else {
        hide(elem);
    }
}

function getById(element) {
    return (typeof element === 'string' || typeof element === 'number') ? document.getElementById(element) : Object;
}

function getByTag(searchTag, node) {
    return (node || document).getElementsByTagName(searchTag);
}

function getByClass(searchClass, node, tag) {
    node = node || document;
    tag = tag || '*';
    var classElements = [],
        nodes = '',
        i = 0,
        l = 0,
        els = 0,
        pattern = 0;

    if (!browser.msie8 && node.querySelectorAll && tag !== '*') {
        return node.querySelectorAll(tag + '.' + searchClass);
    }
    if (node.getElementsByClassName) {
        nodes = node.getElementsByClassName(searchClass);
        if (tag !== '*') {
            tag = tag.toUpperCase();
            for (l = nodes.length; i < l; i += 1) {
                if (nodes[i].tagName.toUpperCase() === tag) {
                    classElements.push(nodes[i]);
                }
            }
        }
        else {
            classElements = Array.prototype.slice.call(nodes);
        }
        return classElements;
    }

    els = getByTag(tag, node);
    pattern = new RegExp('(^|\\s)' + searchClass + '(\\s|$)');
    for (l = els.length; i < l; i += 1) {
        if (pattern.test(els[i].className)) {
            classElements.push(els[i]);
        }
    }
    return classElements;
}

function getByTagOne(searchTag, node) {
    node = node || document;
    return node.querySelector(searchTag) || getByTag(searchTag, node)[0];
}

function insertAfter(parent, node, referenceNode) {
    return parent.insertBefore(node, referenceNode.nextSibling);
}

function insertBefore(parent, node, referenceNode) {
    return parent.insertBefore(node, referenceNode);
}

function getByAttrVal(searchTag, attr, value, node) {
    var el = getByTag(searchTag, node),
        tagElements = [];
    each(el, function (o) {
        if (o.getAttribute(attr) === value) {
            tagElements.push(o);
        }
    });
    return tagElements;
}

function getX(obj) {
    var curleft = 0;
    if (obj.offsetParent) {
        while (true) {
            curleft += obj.offsetLeft;
            if (!obj.offsetParent) {
                break;
            }
            obj = obj.offsetParent;
        }
    }
    else {
        if (obj.x) {
            curleft += obj.x;
        }
    }
    return curleft;
}

function getY(obj) {
    var curtop = 0;
    if (obj.offsetParent) {
        while (true) {
            curtop += obj.offsetTop;
            if (!obj.offsetParent) {
                break;
            }
            obj = obj.offsetParent;
        }
    }
    else {
        if (obj.y) {
            curtop += obj.y;
        }
    }
    return curtop;
}

function remove(object) {
    if (object.length > 0) {
        each(object, function (k) {
            k.parentNode.removeChild(k);
        });
    }
    else {
        if (object && object.parentNode) {
            return object.parentNode.removeChild(object);
        }
    }
}

function replace(object, content) {
    if (object && object.parentNode) {
        return object.parentNode.replaceChild(content, object);
    }
    return object;
}

var css = (function (window) {
    var css = function (elem) {

        var _ = this;
        this.get = function (name) {

            var core_pnum = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source,
                rnumnonpx = new RegExp("^(" + core_pnum + ")(?!px)[a-z%]+$", "i"),
                rposition = /^(top|right|bottom|left)$/,
                ropacity = /opacity=([^)]*)/,
                rmargin = /^margin/;

            if (typeof name != 'string') {
                return '';
            }
            name = name.replace(/\-(\w)/g, function () {
                return arguments[1].toUpperCase();
            });
            var getWidthOrHeight = function (elem, name) {

                var ret = name === "width" ? elem.clientWidth : elem.clientHeight,
                    pt = parseFloat(new css(elem).get('paddingTop')),
                    pb = parseFloat(new css(elem).get('paddingBottom')),
                    pl = parseFloat(new css(elem).get('paddingLeft')),
                    pr = parseFloat(new css(elem).get('paddingRight'));

                ret = (name === "width" ? ret - pl - pr : ret - pt - pb) + 'px';
                return ret;

            };
            var ret, style, computed;

            if (window.getComputedStyle) {
                var width,
                    minWidth,
                    maxWidth;

                computed = window.getComputedStyle(elem, null);
                style = elem.style;
                name = name === "float" ? "cssFloat" : name; //cssFloatfloat

                if (computed) {
                    ret = computed[name];
                    // A tribute to the "awesome hack by Dean Edwards"
                    // Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
                    // Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
                    // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
                    if (rnumnonpx.test(ret) && rmargin.test(name)) {
                        width = style.width;
                        minWidth = style.minWidth;
                        maxWidth = style.maxWidth;

                        style.minWidth = style.maxWidth = style.width = ret;
                        ret = computed.width;

                        style.width = width;
                        style.minWidth = minWidth;
                        style.maxWidth = maxWidth;
                    }
                }

                return ret;
            } else if (document.documentElement.currentStyle) {

                var left,
                    rsLeft;

                style = elem.style;
                ret = elem.currentStyle && elem.currentStyle[name];
                name = name === "float" ? "styleFloat" : name;
                if (name === 'opacity') {

                    return ropacity.test((elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "") ? (0.01 * parseFloat(RegExp.$1)) + "" : 1;

                } else if (name === "width" || name === "height") {

                    if (elem.currentStyle[name] === "auto") {
                        ret = getWidthOrHeight(elem, name);
                        return ret;
                    }

                }

                // Avoid setting ret to empty string here
                // so we don't default to auto
                if (ret === null && style && style[name]) {
                    ret = style[name];
                }

                // From the awesome hack by Dean Edwards
                // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

                // If we're not dealing with a regular pixel number
                // but a number that has a weird ending, we need to convert it to pixels
                // but not position css attributes, as those are proportional to the parent element instead
                // and we can't measure the parent instead because it might trigger a "stacking dolls" problem
                if (rnumnonpx.test(ret) && !rposition.test(name)) {

                    // Remember the original values
                    left = style.left;
                    rsLeft = elem.runtimeStyle && elem.runtimeStyle.left;

                    // Put in the new values to get a computed value out
                    if (rsLeft) {
                        elem.runtimeStyle.left = elem.currentStyle.left;
                    }
                    style.left = name === "fontSize" ? "1em" : ret;
                    ret = style.pixelLeft + "px";

                    // Revert the changed values
                    style.left = left;
                    if (rsLeft) {
                        elem.runtimeStyle.left = rsLeft;
                    }
                }

                return ret === "" ? "auto" : ret;

            } else {
                return elem.style[name];
            }
        };
        this.set = function (name, value) {

            if (name && typeof name == "object" && value === undefined) {
                var tmpStyle = '';
                for (var pro in name) {
                    if (!window.getComputedStyle && pro == 'opacity') {
                        tmpStyle += "filter:alpha(opacity=" + 100 * name[pro] + ");";
                    } else {
                        tmpStyle += pro + ':' + name[pro] + ";";
                    }
                }
                elem.style.cssText += ";" + tmpStyle;
                return;
            }

            name = name.replace(/-([\w])/, function () {
                return arguments[1].toUpperCase();
            });
            if (window.getComputedStyle) {
                name = name === "float" ? "cssFloat" : name;
            } else {
                name = name === "float" ? "styleFloat" : name;
                if (name === "opacity") {
                    elem.style.filter = "alpha(opacity=" + 100 * value + ")";
                }
            }
            elem.style[name] = value;
        };

        this.hasClass = function (name) {
            return elem && (new RegExp('(\\s|^)' + name + '(\\s|$)')).test(elem.className);
        }

        this.addClass = function (name) {
            if (elem && !css(elem).hasClass(name)) {
                elem.className = (elem.className ? elem.className + ' ' : '') + name;
            }
        }

        this.removeClass = function (name) {
            if (elem && css(elem).hasClass(name)) {
                elem.className = trim((elem.className || '').replace((new RegExp('(\\s|^)' + name + '(\\s|$)')), ' '));
            }
        }

        this.replaceClass = function (oldName, newName) {
            css(elem).removeClass(oldName);
            css(elem).addClass(newName);
        }

        this.getSize = function (withoutBounds) {
            var s = [0, 0],
                de = document.documentElement;
            if (elem === document) {
                s = [Math.max(de.clientWidth,
                    bodyNode.scrollWidth,
                    de.scrollWidth,
                    bodyNode.offsetWidth,
                    de.offsetWidth),
                Math.max(de.clientHeight,
                    bodyNode.scrollHeight,
                    de.scrollHeight,
                    bodyNode.offsetHeight,
                    de.offsetHeight)
                ];
            } else if (elem) {
                function getWH() {
                    s = [elem.offsetWidth, elem.offsetHeight];
                    if (!withoutBounds)
                        return;
                    each(s, function (i) {
                        var which = i ? ['Top', 'Bottom'] : ['Left', 'Right'];
                        each(which, function () {
                            s[i] -= parseFloat(css(elem).get('padding' + this)) || 0;
                            s[i] -= parseFloat(css(elem).get('border' + this + 'Width')) || 0;
                        });
                    });
                    s = [Math.round(s[0]), Math.round(s[1])];
                }

                if (!isVisible(elem)) {
                    var props = {
                        position: 'absolute',
                        visibility: 'hidden',
                        display: 'block'
                    };
                    var old = {};
                    each(props, function (i, v) {
                        old[i] = elem.style[i];
                        elem.style[i] = v;
                    });
                    getWH();
                    each(props, function (i) {
                        elem.style[i] = old[i];
                    });
                } else
                    getWH();
            }
            return s;
        }
        return this;
    };

    return function (elem) {
        return new css(elem);
    };

})(window);


messageBox = {
    options: {
        caller: false,
        title: '',
        width: 410,
        height: 'auto',
    },
    boxContainer: false,
    boxTitleWrap: false,
    boxTitle: false,
    boxCloseButton: false,
    boxBody: false,
    boxControls: false,
    boxButton: false,
    overlay: false
};
messageBox.boxes = {};

messageBox.init = function (options) {
    this.options = extend(this.options, options);

    this.boxContainer = createElement('div', {
        className: 'box-container'
    });
    this.boxTitleWrap = createElement('div', {
        className: 'box-title-wrap'
    });
    this.boxTitle = createElement('div', {
        className: 'box-title',
        innerHTML: this.options.title
    });
    this.boxCloseButton = createElement('div', {
        className: 'box-close-button'
    });
    this.boxBody = createElement('div', {
        className: 'box-body'
    });
    this.boxControls = createElement('div', {
        className: 'box-controls'
    });
    this.boxButton = createElement('button', {
        className: 'blue-button f-right',
        innerHTML: ''
    });
    this.overlay = createElement('div', {
        className: 'overlay'
    });
    var patern = new RegExp("<img([^>]*)\/>", "gi");
    if (patern.test(this.options.body)) {
        this.options.body = this.options.body.replace(patern, '<img$1 onload="messageBox.afterLoad(this)" />');
        css(this.boxBody).addClass('loading');
    }
    if (typeof this.options.body == 'object') {
        this.boxBody.appendChild(this.options.body)
    } else {
        this.boxBody.innerHTML = this.options.body;
    }

    this.boxTitleWrap.appendChild(this.boxTitle);
    this.boxTitleWrap.appendChild(this.boxCloseButton);
    this.boxControls.appendChild(this.boxButton);

    this.boxContainer.appendChild(this.boxTitleWrap);
    this.boxContainer.appendChild(this.boxBody);
    this.boxContainer.appendChild(this.boxControls);

    document.body.appendChild(this.boxContainer);
    document.body.appendChild(this.overlay);

    this.overlay.addEvent('click', this.hide);
    this.boxCloseButton.addEvent('click', this.hide);
    this.boxButton.addEvent('click', this.hide);
    document.addEvent('keyup', this.esc);
    window.addEvent('resize', this.resize);
    this.boxes[this.options.caller] = this.boxContainer;
    return messageBox.boxContainer;
};

messageBox.show = function (caller) {
    messageBox.boxContainer = messageBox.boxes[caller];
    show(messageBox.boxContainer);
    messageBox.enableOverlay();
    messageBox.refreshBox();
};

messageBox.hide = function () {
    hide(messageBox.boxContainer);
    messageBox.disableOverlay();
    remove(messageBox.boxContainer);
    remove(messageBox.overlay);
};

messageBox.esc = function (e) {
    e = e || window.event;
    if (e.keyCode == 27) {
        messageBox.hide()
    }
};

messageBox.resize = function () {
    messageBox.boxRefreshCoords();
};
messageBox.afterLoad = function (el) {
    show(el);
    css(messageBox.boxBody).removeClass('loading');
    messageBox.refreshBox();
};

messageBox.refreshBox = function () {
    // Set title
    if (messageBox.options.title) {
        messageBox.boxTitle.innerHTML = messageBox.options.title;
        css(messageBox.boxBody).removeClass('box-no-title');
        show(messageBox.boxTitleWrap);
    } else {
        css(messageBox.boxBody).addClass('box-no-title');
        hide(messageBox.boxTitleWrap);
    }
    // Set box dimensions
    css(messageBox.boxContainer).set('width', typeof (messageBox.options.width) == 'string' ? messageBox.options.width : messageBox.options.width + 'px');
    css(messageBox.boxContainer).set('height', typeof (messageBox.options.height) == 'string' ? messageBox.options.height : messageBox.options.height + 'px');
    messageBox.boxRefreshCoords();
};

messageBox.boxRefreshCoords = function (cont) {
    var height = getHeight();
    var width = getWidth();
    var top = browser.mobile ? intval(window.pageYOffset) : 0;
    var containerSize = css(messageBox.boxContainer).getSize();

    css(messageBox.boxContainer).set('top', Math.max(0, top + (height - containerSize[1]) / 3) + 'px');
    css(messageBox.boxContainer).set('left', (width / 2) - (containerSize[0] / 2) + 'px');

    css(messageBox.overlay).set('height', height + 'px');
    css(messageBox.overlay).set('width', width + 'px');
};

messageBox.enableOverlay = function () {
    show(messageBox.overlay);
};

messageBox.disableOverlay = function () {
    hide(messageBox.overlay);
};
Uploader = {
    options: {
        url: '',
        dropBox: {},
        imageFile: {},
        paramname: {},
        data: {},
        csrf: '',
        chooseButton: {},
        onChange: emptyFunction,
        onDragEnter: emptyFunction,
        onDragLeave: emptyFunction,
        onDragOver: emptyFunction,
        onDrop: emptyFunction,
        onBeforeUpload: emptyFunction,
        onProgress: emptyFunction,
        onLoad: emptyFunction
    },
    over: {},
    leave: {},
    init: function (options) {
        this.options = extend(this.options, options);

        this.options.dropBox = getById(this.options.dropBox);
        this.options.imageFile = getById(this.options.imageFile);
        this.options.chooseButton = getById(this.options.chooseButton);

        this.options.imageFile.addEvent("change", function (e) {
            Uploader.traverseFiles(this.files);
        }, false);

        this.leave = this.options.dropBox.firstChild.nextSibling;
        this.over = this.options.dropBox.lastChild.previousSibling;

        document.addEvent("dragover", function (e) {
            e.preventDefault();
            var target = e.target;
            if (target && target === Uploader.options.dropBox || target.parentNode === Uploader.options.dropBox) {
                Uploader.options.dropBox.className = "over";
                Uploader.leave.style.display = 'none';
                Uploader.over.style.display = 'block';
                Uploader.over.innerHTML = '     ';
            } else {
                Uploader.options.dropBox.className = "";
                Uploader.leave.style.display = 'none';
                Uploader.over.style.display = 'block';
                Uploader.over.innerHTML = '  ';
            }

        }, false);

        document.addEvent("dragend", function (e) {
            e.preventDefault();
            var target = e.target;
            Uploader.options.dropBox.className = "";
            Uploader.leave.style.display = 'block';
            Uploader.over.style.display = 'none';
        }, false);

        document.addEvent("drop", function (e) {
            e.preventDefault();
            var target = e.target;
            Uploader.options.dropBox.className = "";
            Uploader.leave.style.display = 'block';
            Uploader.over.style.display = 'none';

            if (target && target === Uploader.options.dropBox || target.parentNode === Uploader.options.dropBox) {

                Uploader.options.onDrop(e);
                Uploader.traverseFiles(e.dataTransfer.files);
            }
            this.className = "";
        }, false);
    },

    getBuilder: function (file, filedata, boundary) {
        var dashdash = '--', crlf = '\r\n', builder = '';

        each(this.options.data, function (i, val) {
            if (typeof val === 'function')
                val = val();
            builder += dashdash;
            builder += boundary;
            builder += crlf;
            builder += 'Content-Disposition: form-data; name="' + i + '"';
            builder += crlf;
            builder += crlf;
            builder += val;
            builder += crlf;
        });

        builder += dashdash;
        builder += boundary;
        builder += crlf;
        builder += 'Content-Disposition: form-data; name="' + this.options.paramname + '"';
        builder += '; filename="' + encodeURI(file.name) + '"';
        builder += crlf;

        builder += 'Content-Type: ' + file.type || 'application/octet-stream';
        builder += crlf;
        builder += crlf;

        builder += filedata;
        builder += crlf;

        builder += dashdash;
        builder += boundary;

        builder += crlf;
        return builder;
    },

    uploadFile: function (file) {
        if (Uploader.checkBrowser() && (/image/i).test(file.type)) {
            var reader = new FileReader();
            Uploader.options.onBeforeUpload(file);
            reader.addEvent('loadend', Uploader.send);
            reader.readAsBinaryString(file);
        }
    },

    checkBrowser: function () {
        return (window.File && window.FileReader) ? true : false;
    },

    send: function (e) {
        xhr = new XMLHttpRequest();

        xhr.onreadystatechange = Uploader.onreadystatechange;

        start_time = new Date().getTime();
        boundary = '----imageboundary' + (new Date).getTime();
        xhr.upload.file = Uploader.options.imageFile;
        xhr.upload.downloadStartTime = start_time;
        xhr.upload.currentStart = start_time;
        xhr.upload.currentProgress = 0;
        xhr.upload.startData = 0;

        builder = e.target.result ? Uploader.getBuilder(xhr.upload.file, e.target.result, boundary) : xhr.upload.file;

        xhr.upload.addEvent("progress", function (e) {
            Uploader.options.onProgress(e);
        }, false);

        xhr.upload.addEvent("load", function (e) {
            try { response = eval("(" + xhr.responseText + ")"); }
            catch (err) { response = {}; }
        }, false);
        xhr.upload.addEvent("error", function (e) {
            Uploader.options.onLoad(xhr.responseText);
        }, false);

        xhr.open("POST", Uploader.options.url);

        xhr.setRequestHeader('Content-type', 'multipart/form-data; boundary="' + boundary + '"');
        xhr.setRequestHeader('Cache-Control', 'no-cache');
        xhr.setRequestHeader('X-File-Name', xhr.upload.file.name);
        xhr.setRequestHeader('X-File-Size', xhr.upload.file.size);
        xhr.setRequestHeader('X-File-Type', xhr.upload.file.type);
        if (Uploader.options.csrf) {
            xhr.setRequestHeader('X-CSRF-Token', Uploader.options.csrf);
        }
        if (xhr.sendAsBinary) {// Gecko
            xhr.sendAsBinary(builder);
        } else {// WebKit with typed arrays support
            var ui8a = new Uint8Array(builder.length);
            for (var i = 0; i < builder.length; i++) {
                ui8a[i] = (builder.charCodeAt(i) & 0xff);
            }
            try {
                xhr.send(ui8a);
            } catch (error) {
                xhr.send(ui8a.buffer);
            }
        }
    },

    onprogress: function (e) {
        if (e.lengthComputable) {
            var percentage = Math.round((e.loaded * 100) / e.total);
            itemUI.progress(percentage);
        }
    },

    onComplete: function () {
        var response;

        if (xhr.status == 201 || xhr.status == 200) {

            try { response = eval("(" + xhr.responseText + ")"); }
            catch (err) { response = {}; }
            this.options.onLoad(response);
        }
    },

    onreadystatechange: function () {
        if (xhr.readyState == 4) { Uploader.onComplete(); }
    },

    traverseFiles: function (files) {
        if (typeof files !== "undefined") {
            for (var i = 0, l = files.length; i < l; i++) {
                this.options.imageFile = files[i];
                this.uploadFile(files[i]);
            }
        } else {
            console.log("No support for the File API in this web");
        }
    }
};
onDomReady(function () {

    app = {};
    alert('asd');
    app.ddmenuitem = null;
    app.utime = setInterval(updateTime, 30000);
    updateTime();

    document.onclick = app.dropdown;

    app.review = {
        actionStatus: false,
        showedOnlyAnonymous: false
    };

    var reviews = getByTag('article', getById('profile-reviews'));
    app.review.countAll = reviews.length;

    reviews && each(reviews, function (o) {
        o.addEvent('mouseover', function () {
            var qa = getByClass('review-actions', this)[0];
            css(qa).set('opacity', 1);
        });
    });

    reviews && each(reviews, function (o) {
        o.addEvent('mouseout', function () {
            var qa = getByClass('review-actions', this)[0];
            css(qa).set('opacity', 0);
        });
    });

    app.review.toggleForm = function () {
        if (!app.review.showedForm) {
            hide(getById('show-form-link'));
            show(getById('review-form-container'));
            app.review.showedForm = true;
        }
        else {
            show(getById('show-form-link'));
            hide(getById('review-form-container'));
            app.review.showedForm = false;
        }

    };

    app.review.toggleActions = function (el) {
        var qa = getByClass('review-actions', el, 'div');
        if (qa && qa.length) {
            qa = qa[0];
            if (app.review.actionStatus) {
                css(qa).set('visibility', 'hidden');
                css(qa).set('opacity', 0);
                app.review.actionStatus = false;
            }
            else {
                css(qa).set('visibility', 'visible');
                css(qa).set('opacity', 1);
                app.review.actionStatus = true;
            }

        }
    };

    app.review.toggleReviews = function (e) {
        var self = e;
        var data = getByClass('review-unknown');
        var title = getById('wall-title');
        if (!app.review.showedOnlyAnonymous) {
            self.innerHTML = ' ';
            title.innerHTML = app.review.countAll - data.length + ' ';
            each(data, function (o) {
                hide(o);
            });
            app.review.showedOnlyAnonymous = true;
        }
        else {
            self.innerHTML = ' ';
            title.innerHTML = app.review.countAll + ' ';
            each(data, function (o) {
                show(o);
            });
            app.review.showedOnlyAnonymous = false;
        }
    };

    var reviewText = getById('review-text');
    var wordCounter = getById('review-word-counter');

    reviewText && reviewText.addEvent('keydown', function () {
        var l = parseInt(this.value.length + 1);
        if (l < 255) {
            wordCounter.innerHTML = 255 - l;
        }

    });
});

app.dropdown = function (id) {


    if (app.ddmenuitem) {
        hide(app.ddmenuitem);
        app.ddmenuitem = null;
    }
    else {
        if (typeof id == 'string') {
            app.ddmenuitem = getById(id);
            app.ddmenuitem.style.display = 'block';
            //show(app.ddmenuitem);
        }
    }
    if (typeof id == 'object') {
        id.stopPropagation();
    }

}

app.profile = {};

app.profile.showPhoto = function (e) {
    messageBox.init({
        caller: e,
        width: 640,
        title: ' ',
        body: '<img src="' + e.href + '" />'
    });
    messageBox.show(e);
    return false;
};

app.profile.changePhoto = function (c) {
    var caller = c;
    var el = getById('dropbox');
    if (el) {
        show(caller);
    }
    else {
        majaX({
            url: '/user/upload',
            type: 'html',
            method: 'GET',
        }, function (data) {
            messageBox.init({
                caller: c,
                title: ' ',
                body: data,
                width: 450
            });

            messageBox.show(c);
            var dropbox = getById('dropbox');

            var previewContainer,
                imageHolder,
                uploadedBadge,
                uploadProgressHolder,
                uploadProgressBar,
                image,
                messageContainer;

            uploadProgressHolder = createElement('div', {
                id: 'upload-progress-holder',
                innerHTML: '<div ></div>'
            });

            uploadProgressBar = createElement('div', {
                id: 'upload-progress'
            });
            uploadProgressHolder.appendChild(uploadProgressBar);

            previewContainer = createElement('div', {
                className: 'preview'
            });
            imageHolder = createElement('span', {
                className: 'imageHolder'
            });
            uploadedBadge = createElement('span', {
                className: 'uploaded'
            });
            messageContainer = createElement('div', {
                className: 'message'
            });
            previewContainer.appendChild(imageHolder);
            previewContainer.appendChild(uploadProgressHolder)
            previewContainer.appendChild(messageContainer);

            image = createElement('img');
            Uploader.init({
                dropBox: 'dropbox',
                imageFile: 'image-file',
                paramname: 'image',
                csrf: app.csrfToken,
                url: '/user/upload',
                onBeforeUpload: function (file) {
                    dropbox.innerHTML = '';
                    dropbox.appendChild(previewContainer);
                    show(uploadedBadge);
                    messageContainer.innerHTML = '   ';

                    var reader = new FileReader();
                    reader.onload = function (e) {
                        image = createElement('img', {
                            src: e.target.result,
                        });
                        imageHolder.appendChild(image);
                    }
                    reader.readAsDataURL(file);

                    messageContainer.innerHTML = ',  ...';
                    show(uploadProgressHolder);
                },
                onProgress: function (e) {
                    css(uploadProgressBar).set('width', (e.loaded / e.total) * 100 + "%");
                },
                onLoad: function (data) {
                    imageHolder.appendChild(uploadedBadge);
                    getById('current-profile-image').src = '/uploads/' + data.files[0].name;
                    getById('current-profile-image').parentNode.href = '/uploads/' + data.files[0].name;
                    show(uploadedBadge);
                    hide(uploadProgressHolder);
                    messageContainer.innerHTML = '   ';
                    // $("#header-notifier").removeClass("error").addClass("info").html('
                    //   ');
                }
            });
        });
    }
};

app.profile.follow = function (o) {
    majaX({
        url: '/user/follow',
        type: 'json',
        method: 'POST',
        data: {
            '_csrf': encodeURIComponent(app.csrfToken),
            'uid': app.uid
        }
    }, function (a) {
        if (a.status == 1) {
            o.innerHTML = '';
            o.setAttribute('onclick', 'app.profile.unfollow(this)');
        }
    });
};

app.profile.unfollow = function (o) {
    majaX({
        url: '/user/unfollow',
        type: 'json',
        method: 'POST',
        data: {
            '_csrf': encodeURIComponent(app.csrfToken),
            'uid': app.uid
        }
    }, function (a) {
        if (a.status == 1) {
            o.innerHTML = '';
            o.setAttribute('onclick', 'app.profile.follow(this)');
        }
    });
};

function updateTime() {
    var qa = getByClass('timeago', document.body);
    each(qa, function (k) {
        k.innerHTML = timeAgo(parseInt(k.getAttribute('datetime') || k.getAttribute('title')));
    });
}

function getCsrfTokenString() {
    return '' + app.csrfToken.name + '=' + '';
}

function timeAgo(time) {
    time = Math.round((Date.now() - (time)) / 1000);
    if (time < 5) return " ";
    else if (time < 60) return '  ';
    else if (time < 3600) return declOfNum((time - (time % 60)) / 60, ['', '', '']) + ' ';
    else if (time < 86400) return declOfNum((time - (time % 3600)) / 3600, ['', '', '']) + ' ';
    else if (time < 2073600) return declOfNum((time - (time % 86400)) / 86400, ['', '', '']) + ' ';
    else if (time < 62208000) return declOfNum((time - (time % 2073600)) / 2073600, ['', '', '']) + ' ';
}

function declOfNum(number, titles) {
    var cases = [2, 0, 1, 1, 1, 2];
    return number + ' ' + titles[(number % 100 > 4 && number % 100 < 20) ? 2 : cases[(number % 10 < 5) ? number % 10 : 5]];
}